Understanding "inverse" and  "cascade" attributes :-
**************************************************
=> The "inverse" and  "cascade" attributes can be specified in the <list> , <set> ,<map> and <bag> tag's.

"inverse" :-
**********
	"inverse" attribute will allways specifies the owner of the relationship.

	Ingenerally when we try to insert the Department record into the table.
 Hibernate Engine does the following job's.
	1.Submits the Select query to the Employee table by passing employeeId.

	2.Then inserts the Department record.

	3.If the EmployeeId is existed in the Employee table directly  updates Dept_Fk_Id within the Employee table.

	4.If the EmployeeId is not existed in the Employee table first Hibernate Engine insert the Employee record then updates Dept_Fk_Id within the Employee table.

=> Here the update statement is generated by the HibernateEngine based on the owner(i.e parent) of the relationship.

=> By default attribute value of "inverse" is "false".

<hibernate-mapping>
<class name="com.nit.Department" table="Department">
....
....
<set name="employeesSet" table="Employee"
cascade="all" inverse="false">
....
</set>
</class>
</hibernate-mapping>

=> Which indicate the "Employee" table is not the owner of the relationship.

=>Here the owner of the relationship is "Department" So that when we try to insert Department record the Department Id will be updated in the "Employee" table

***********************
<set name="employeesSet" table="Employee"
cascade="all" inverse="true">
....
</set>

If we make inverse="true" then the "Employee" table will becomes Owner of the relationship.

Then If we insert Department record , the Department Id is not going to be updated within the Employee table.
********************************
Orphan Record :-
*************
	=>If the child record is not refered by any parent id then that can be called as Orphan Record.




"cascade" attributes :-
********************
cascade ="none" 
This is the default attribute.

If we don't configure cascade attribute this will enabled.

<set name="employeesSet" table="Employee"
cascade="none" inverse="false">
.....
.....
</set>

Case 1:	Insertion :-
	**********
	** When we insert a parent object , the child records won't be inserted.

	**	The parent_fk_id will be updated in the child record.
	

Case 2:	Deletion :-
	*********
	=> When we delete parent record , the child records won't be deleted.
	**The child records  parent_fk_id will be updated as 'null' .
	=> These records can be called "Orphan_Records".



cascade ="save-update"
************
	Case 1:	Insertion :-
		**********
	Take the 1,2,3,4 points from inverse="false" attribute .
	
Case 2:	Deletion :-
	*********
		same as cascade="none" case 2.
	

cascade ="delete"
*****************
	Case 1:	Insertion :-
		**********
	same as cascade="none" case 1

Case 2:	Deletion :-
	*********
	When we try to delete parent records all the child records will be deleted.


cascade ="all"
**************
	case 1 :- Insertion
		************
Same as cascade="save-update" case 1

	case 2 : Deletion 
		*********
Same as cascade="delete" case 2

=> "inverse" and "cascade" attributes will used to tune the Non-Select operations .

=>"lazy" ,"batch-size" , "fetch" attributes will be used to tune the "Select Operations".

=>All these above tags can be applicable on "<list>","<bag>","<set>","<map>" tag.

=> "fetch" attributes :-
  **********************
	fetch="select" :-
	****************
=>   The fetch="select" will submit select query to Employee table for every department Id.

	If there are 10 department's in the Department table then the "10" select Query will be submited to the Employee table.

<set name="employeesSet" table="Employee"
cascade="save-update" inverse="false"  
lazy="false"  fetch="select"  >
....
....
</set>

Sample Generated Queries by HibernateEngine :-
********************************************
Select * From Department;
Select * From Employee Where Dept_FK_ID=1;
Select * From Employee Where Dept_FK_ID=2;
.....
So incase of fetch="select" Hibernate Engine will select the data collection by collection or Department by Department.

"batch-size" :-
**************
=> Here we can select the Employee object's batch by batch

<set name="employeesSet" table="Employee"
cascade="save-update" inverse="false"  
lazy="false"  batch-size="3" fetch="select"  >
....
....
</set>

Here the Hibernate Engine will submit a select query to the Employee table for every three department id's.
Sample Queries :-
Select * From Department;
Select * From Employee where Dept_FK_ID in(1,2,3);
Select * From Employee where Dept_FK_ID in(4,5,6);
.....etc

fetch="subselect"
****************
Here Hibernate Engine uses sub queries.
Hibernate Engine pass the complete Department Id's to the Employee as an inner query.

<set name="employeesSet" table="Employee"
cascade="save-update" inverse="false"  
lazy="false"  fetch="subselect"  >
....
....
</set>

Sample Query:-
*************
Select * From Department;

Select * From Employee where Dept_Fk_Id in (Select Dept_Id From Department);

fetch="join":-
************
If we use fecth="join" internally Hibernate Engine will uses "Left Outer Join" concept to fetch the Employee Records.

Sample Query
Select * From Employee emp
left Join Department dept  ON(emp.Dept_FK_ID = dept.Dept_Id);

 Developing OneToMany and ManyToOne relationship using annotations :-
***********************************************
=>@OneToMany annotation can be used to map <one-to-many> relationship.

=>@OneToMany contains following attributes

	**fetch
          *****
		This is use to specify either the "FetchType" is EAGER or LAZY.

		fetch=FetchType.EAGER

	
class Department
	{
	....
@OneToMany(cascade = CascadeType.ALL,fetch = FetchType.EAGER)
	@Fetch(FetchMode.SUBSELECT)
	@JoinColumn(name = "DEPT_FK_ID")
Set<Employee> employeeSet =null;
....
	}

class Employee
{
.....

	@ManyToOne(cascade = CascadeType.MERGE,fetch = FetchType.EAGER)
	@JoinColumn(name = "DEPT_FK_ID")
Department dept;
}


If we use "mappedBy" attribute we no need to specify  Foriegn Key within the Department.

@JoinColumn :- Is used to configure the Foreign Key Column.

@ManyToOne :- Is used to specify <many-to-one> relationship.


@Fetch :-
******	Specifies the Selction Criteria.

@Fetch(FetchMode.SELECT)


************************
To configure our own generator within the Persistence class we can make use of 
	@GenericGenerator and @GeneratedValue annotaitons.

=>@GenericGenerator configures the generator class
=>@GeneratedValue applys the generator to the id.

@Id
@GenericGenerator(name="icr",strategy="increment")
		@GeneratedValue(generator="icr")
		@Column(name = "Dept_Id")

Here the "icr" is the nick name for "increment" generator.
We will use this nick name within the @GeneratedValue annotation.
***************
Note :-
**** 
@GenericGenerator , @Fetch ,FetchMode these three are available within the "org.hibernate.annotations" package.

Remaining all the annotations and support classes are available in "javax.persistence" package.

hibernate.cfg.xml
*****************
<mapping class="com.nit.Department" />
<mapping class="com.nit.Employee" />

HBUtil.java
EmployeeDAO.java
EmployeeApp.java
 take these files from previous OneToMany Application.

Procedure to run :
1.sql script :

delete From Employee;
delete From Department;
insert into Department values(1,'Java');
commit;

2. Run the EmployeeApp.java

